// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'import_token_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ImportTokenEventTearOff {
  const _$ImportTokenEventTearOff();

  _ImportTokenEventAdd add() {
    return const _ImportTokenEventAdd();
  }

  _ImportTokenEventLoad loadInfo() {
    return const _ImportTokenEventLoad();
  }

  _ImportTokenEventAddressChanged addressChanged(String tokenAddress) {
    return _ImportTokenEventAddressChanged(
      tokenAddress,
    );
  }

  _ImportTokenEventSymbolChanged symbolChanged(String tokenSymbol) {
    return _ImportTokenEventSymbolChanged(
      tokenSymbol,
    );
  }

  _ImportTokenEventDecimalChanged decimalChanged(String tokenDecimal) {
    return _ImportTokenEventDecimalChanged(
      tokenDecimal,
    );
  }
}

/// @nodoc
const $ImportTokenEvent = _$ImportTokenEventTearOff();

/// @nodoc
mixin _$ImportTokenEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() loadInfo,
    required TResult Function(String tokenAddress) addressChanged,
    required TResult Function(String tokenSymbol) symbolChanged,
    required TResult Function(String tokenDecimal) decimalChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ImportTokenEventAdd value) add,
    required TResult Function(_ImportTokenEventLoad value) loadInfo,
    required TResult Function(_ImportTokenEventAddressChanged value)
        addressChanged,
    required TResult Function(_ImportTokenEventSymbolChanged value)
        symbolChanged,
    required TResult Function(_ImportTokenEventDecimalChanged value)
        decimalChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImportTokenEventCopyWith<$Res> {
  factory $ImportTokenEventCopyWith(
          ImportTokenEvent value, $Res Function(ImportTokenEvent) then) =
      _$ImportTokenEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$ImportTokenEventCopyWithImpl<$Res>
    implements $ImportTokenEventCopyWith<$Res> {
  _$ImportTokenEventCopyWithImpl(this._value, this._then);

  final ImportTokenEvent _value;
  // ignore: unused_field
  final $Res Function(ImportTokenEvent) _then;
}

/// @nodoc
abstract class _$ImportTokenEventAddCopyWith<$Res> {
  factory _$ImportTokenEventAddCopyWith(_ImportTokenEventAdd value,
          $Res Function(_ImportTokenEventAdd) then) =
      __$ImportTokenEventAddCopyWithImpl<$Res>;
}

/// @nodoc
class __$ImportTokenEventAddCopyWithImpl<$Res>
    extends _$ImportTokenEventCopyWithImpl<$Res>
    implements _$ImportTokenEventAddCopyWith<$Res> {
  __$ImportTokenEventAddCopyWithImpl(
      _ImportTokenEventAdd _value, $Res Function(_ImportTokenEventAdd) _then)
      : super(_value, (v) => _then(v as _ImportTokenEventAdd));

  @override
  _ImportTokenEventAdd get _value => super._value as _ImportTokenEventAdd;
}

/// @nodoc

class _$_ImportTokenEventAdd implements _ImportTokenEventAdd {
  const _$_ImportTokenEventAdd();

  @override
  String toString() {
    return 'ImportTokenEvent.add()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ImportTokenEventAdd);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() loadInfo,
    required TResult Function(String tokenAddress) addressChanged,
    required TResult Function(String tokenSymbol) symbolChanged,
    required TResult Function(String tokenDecimal) decimalChanged,
  }) {
    return add();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
  }) {
    return add?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ImportTokenEventAdd value) add,
    required TResult Function(_ImportTokenEventLoad value) loadInfo,
    required TResult Function(_ImportTokenEventAddressChanged value)
        addressChanged,
    required TResult Function(_ImportTokenEventSymbolChanged value)
        symbolChanged,
    required TResult Function(_ImportTokenEventDecimalChanged value)
        decimalChanged,
  }) {
    return add(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
  }) {
    return add?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
    required TResult orElse(),
  }) {
    if (add != null) {
      return add(this);
    }
    return orElse();
  }
}

abstract class _ImportTokenEventAdd implements ImportTokenEvent {
  const factory _ImportTokenEventAdd() = _$_ImportTokenEventAdd;
}

/// @nodoc
abstract class _$ImportTokenEventLoadCopyWith<$Res> {
  factory _$ImportTokenEventLoadCopyWith(_ImportTokenEventLoad value,
          $Res Function(_ImportTokenEventLoad) then) =
      __$ImportTokenEventLoadCopyWithImpl<$Res>;
}

/// @nodoc
class __$ImportTokenEventLoadCopyWithImpl<$Res>
    extends _$ImportTokenEventCopyWithImpl<$Res>
    implements _$ImportTokenEventLoadCopyWith<$Res> {
  __$ImportTokenEventLoadCopyWithImpl(
      _ImportTokenEventLoad _value, $Res Function(_ImportTokenEventLoad) _then)
      : super(_value, (v) => _then(v as _ImportTokenEventLoad));

  @override
  _ImportTokenEventLoad get _value => super._value as _ImportTokenEventLoad;
}

/// @nodoc

class _$_ImportTokenEventLoad implements _ImportTokenEventLoad {
  const _$_ImportTokenEventLoad();

  @override
  String toString() {
    return 'ImportTokenEvent.loadInfo()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ImportTokenEventLoad);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() loadInfo,
    required TResult Function(String tokenAddress) addressChanged,
    required TResult Function(String tokenSymbol) symbolChanged,
    required TResult Function(String tokenDecimal) decimalChanged,
  }) {
    return loadInfo();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
  }) {
    return loadInfo?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
    required TResult orElse(),
  }) {
    if (loadInfo != null) {
      return loadInfo();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ImportTokenEventAdd value) add,
    required TResult Function(_ImportTokenEventLoad value) loadInfo,
    required TResult Function(_ImportTokenEventAddressChanged value)
        addressChanged,
    required TResult Function(_ImportTokenEventSymbolChanged value)
        symbolChanged,
    required TResult Function(_ImportTokenEventDecimalChanged value)
        decimalChanged,
  }) {
    return loadInfo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
  }) {
    return loadInfo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
    required TResult orElse(),
  }) {
    if (loadInfo != null) {
      return loadInfo(this);
    }
    return orElse();
  }
}

abstract class _ImportTokenEventLoad implements ImportTokenEvent {
  const factory _ImportTokenEventLoad() = _$_ImportTokenEventLoad;
}

/// @nodoc
abstract class _$ImportTokenEventAddressChangedCopyWith<$Res> {
  factory _$ImportTokenEventAddressChangedCopyWith(
          _ImportTokenEventAddressChanged value,
          $Res Function(_ImportTokenEventAddressChanged) then) =
      __$ImportTokenEventAddressChangedCopyWithImpl<$Res>;
  $Res call({String tokenAddress});
}

/// @nodoc
class __$ImportTokenEventAddressChangedCopyWithImpl<$Res>
    extends _$ImportTokenEventCopyWithImpl<$Res>
    implements _$ImportTokenEventAddressChangedCopyWith<$Res> {
  __$ImportTokenEventAddressChangedCopyWithImpl(
      _ImportTokenEventAddressChanged _value,
      $Res Function(_ImportTokenEventAddressChanged) _then)
      : super(_value, (v) => _then(v as _ImportTokenEventAddressChanged));

  @override
  _ImportTokenEventAddressChanged get _value =>
      super._value as _ImportTokenEventAddressChanged;

  @override
  $Res call({
    Object? tokenAddress = freezed,
  }) {
    return _then(_ImportTokenEventAddressChanged(
      tokenAddress == freezed
          ? _value.tokenAddress
          : tokenAddress // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ImportTokenEventAddressChanged
    implements _ImportTokenEventAddressChanged {
  const _$_ImportTokenEventAddressChanged(this.tokenAddress);

  @override
  final String tokenAddress;

  @override
  String toString() {
    return 'ImportTokenEvent.addressChanged(tokenAddress: $tokenAddress)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImportTokenEventAddressChanged &&
            const DeepCollectionEquality()
                .equals(other.tokenAddress, tokenAddress));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(tokenAddress));

  @JsonKey(ignore: true)
  @override
  _$ImportTokenEventAddressChangedCopyWith<_ImportTokenEventAddressChanged>
      get copyWith => __$ImportTokenEventAddressChangedCopyWithImpl<
          _ImportTokenEventAddressChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() loadInfo,
    required TResult Function(String tokenAddress) addressChanged,
    required TResult Function(String tokenSymbol) symbolChanged,
    required TResult Function(String tokenDecimal) decimalChanged,
  }) {
    return addressChanged(tokenAddress);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
  }) {
    return addressChanged?.call(tokenAddress);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
    required TResult orElse(),
  }) {
    if (addressChanged != null) {
      return addressChanged(tokenAddress);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ImportTokenEventAdd value) add,
    required TResult Function(_ImportTokenEventLoad value) loadInfo,
    required TResult Function(_ImportTokenEventAddressChanged value)
        addressChanged,
    required TResult Function(_ImportTokenEventSymbolChanged value)
        symbolChanged,
    required TResult Function(_ImportTokenEventDecimalChanged value)
        decimalChanged,
  }) {
    return addressChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
  }) {
    return addressChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
    required TResult orElse(),
  }) {
    if (addressChanged != null) {
      return addressChanged(this);
    }
    return orElse();
  }
}

abstract class _ImportTokenEventAddressChanged implements ImportTokenEvent {
  const factory _ImportTokenEventAddressChanged(String tokenAddress) =
      _$_ImportTokenEventAddressChanged;

  String get tokenAddress;
  @JsonKey(ignore: true)
  _$ImportTokenEventAddressChangedCopyWith<_ImportTokenEventAddressChanged>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ImportTokenEventSymbolChangedCopyWith<$Res> {
  factory _$ImportTokenEventSymbolChangedCopyWith(
          _ImportTokenEventSymbolChanged value,
          $Res Function(_ImportTokenEventSymbolChanged) then) =
      __$ImportTokenEventSymbolChangedCopyWithImpl<$Res>;
  $Res call({String tokenSymbol});
}

/// @nodoc
class __$ImportTokenEventSymbolChangedCopyWithImpl<$Res>
    extends _$ImportTokenEventCopyWithImpl<$Res>
    implements _$ImportTokenEventSymbolChangedCopyWith<$Res> {
  __$ImportTokenEventSymbolChangedCopyWithImpl(
      _ImportTokenEventSymbolChanged _value,
      $Res Function(_ImportTokenEventSymbolChanged) _then)
      : super(_value, (v) => _then(v as _ImportTokenEventSymbolChanged));

  @override
  _ImportTokenEventSymbolChanged get _value =>
      super._value as _ImportTokenEventSymbolChanged;

  @override
  $Res call({
    Object? tokenSymbol = freezed,
  }) {
    return _then(_ImportTokenEventSymbolChanged(
      tokenSymbol == freezed
          ? _value.tokenSymbol
          : tokenSymbol // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ImportTokenEventSymbolChanged
    implements _ImportTokenEventSymbolChanged {
  const _$_ImportTokenEventSymbolChanged(this.tokenSymbol);

  @override
  final String tokenSymbol;

  @override
  String toString() {
    return 'ImportTokenEvent.symbolChanged(tokenSymbol: $tokenSymbol)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImportTokenEventSymbolChanged &&
            const DeepCollectionEquality()
                .equals(other.tokenSymbol, tokenSymbol));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(tokenSymbol));

  @JsonKey(ignore: true)
  @override
  _$ImportTokenEventSymbolChangedCopyWith<_ImportTokenEventSymbolChanged>
      get copyWith => __$ImportTokenEventSymbolChangedCopyWithImpl<
          _ImportTokenEventSymbolChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() loadInfo,
    required TResult Function(String tokenAddress) addressChanged,
    required TResult Function(String tokenSymbol) symbolChanged,
    required TResult Function(String tokenDecimal) decimalChanged,
  }) {
    return symbolChanged(tokenSymbol);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
  }) {
    return symbolChanged?.call(tokenSymbol);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
    required TResult orElse(),
  }) {
    if (symbolChanged != null) {
      return symbolChanged(tokenSymbol);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ImportTokenEventAdd value) add,
    required TResult Function(_ImportTokenEventLoad value) loadInfo,
    required TResult Function(_ImportTokenEventAddressChanged value)
        addressChanged,
    required TResult Function(_ImportTokenEventSymbolChanged value)
        symbolChanged,
    required TResult Function(_ImportTokenEventDecimalChanged value)
        decimalChanged,
  }) {
    return symbolChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
  }) {
    return symbolChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
    required TResult orElse(),
  }) {
    if (symbolChanged != null) {
      return symbolChanged(this);
    }
    return orElse();
  }
}

abstract class _ImportTokenEventSymbolChanged implements ImportTokenEvent {
  const factory _ImportTokenEventSymbolChanged(String tokenSymbol) =
      _$_ImportTokenEventSymbolChanged;

  String get tokenSymbol;
  @JsonKey(ignore: true)
  _$ImportTokenEventSymbolChangedCopyWith<_ImportTokenEventSymbolChanged>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$ImportTokenEventDecimalChangedCopyWith<$Res> {
  factory _$ImportTokenEventDecimalChangedCopyWith(
          _ImportTokenEventDecimalChanged value,
          $Res Function(_ImportTokenEventDecimalChanged) then) =
      __$ImportTokenEventDecimalChangedCopyWithImpl<$Res>;
  $Res call({String tokenDecimal});
}

/// @nodoc
class __$ImportTokenEventDecimalChangedCopyWithImpl<$Res>
    extends _$ImportTokenEventCopyWithImpl<$Res>
    implements _$ImportTokenEventDecimalChangedCopyWith<$Res> {
  __$ImportTokenEventDecimalChangedCopyWithImpl(
      _ImportTokenEventDecimalChanged _value,
      $Res Function(_ImportTokenEventDecimalChanged) _then)
      : super(_value, (v) => _then(v as _ImportTokenEventDecimalChanged));

  @override
  _ImportTokenEventDecimalChanged get _value =>
      super._value as _ImportTokenEventDecimalChanged;

  @override
  $Res call({
    Object? tokenDecimal = freezed,
  }) {
    return _then(_ImportTokenEventDecimalChanged(
      tokenDecimal == freezed
          ? _value.tokenDecimal
          : tokenDecimal // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ImportTokenEventDecimalChanged
    implements _ImportTokenEventDecimalChanged {
  const _$_ImportTokenEventDecimalChanged(this.tokenDecimal);

  @override
  final String tokenDecimal;

  @override
  String toString() {
    return 'ImportTokenEvent.decimalChanged(tokenDecimal: $tokenDecimal)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImportTokenEventDecimalChanged &&
            const DeepCollectionEquality()
                .equals(other.tokenDecimal, tokenDecimal));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(tokenDecimal));

  @JsonKey(ignore: true)
  @override
  _$ImportTokenEventDecimalChangedCopyWith<_ImportTokenEventDecimalChanged>
      get copyWith => __$ImportTokenEventDecimalChangedCopyWithImpl<
          _ImportTokenEventDecimalChanged>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() add,
    required TResult Function() loadInfo,
    required TResult Function(String tokenAddress) addressChanged,
    required TResult Function(String tokenSymbol) symbolChanged,
    required TResult Function(String tokenDecimal) decimalChanged,
  }) {
    return decimalChanged(tokenDecimal);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
  }) {
    return decimalChanged?.call(tokenDecimal);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? add,
    TResult Function()? loadInfo,
    TResult Function(String tokenAddress)? addressChanged,
    TResult Function(String tokenSymbol)? symbolChanged,
    TResult Function(String tokenDecimal)? decimalChanged,
    required TResult orElse(),
  }) {
    if (decimalChanged != null) {
      return decimalChanged(tokenDecimal);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ImportTokenEventAdd value) add,
    required TResult Function(_ImportTokenEventLoad value) loadInfo,
    required TResult Function(_ImportTokenEventAddressChanged value)
        addressChanged,
    required TResult Function(_ImportTokenEventSymbolChanged value)
        symbolChanged,
    required TResult Function(_ImportTokenEventDecimalChanged value)
        decimalChanged,
  }) {
    return decimalChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
  }) {
    return decimalChanged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ImportTokenEventAdd value)? add,
    TResult Function(_ImportTokenEventLoad value)? loadInfo,
    TResult Function(_ImportTokenEventAddressChanged value)? addressChanged,
    TResult Function(_ImportTokenEventSymbolChanged value)? symbolChanged,
    TResult Function(_ImportTokenEventDecimalChanged value)? decimalChanged,
    required TResult orElse(),
  }) {
    if (decimalChanged != null) {
      return decimalChanged(this);
    }
    return orElse();
  }
}

abstract class _ImportTokenEventDecimalChanged implements ImportTokenEvent {
  const factory _ImportTokenEventDecimalChanged(String tokenDecimal) =
      _$_ImportTokenEventDecimalChanged;

  String get tokenDecimal;
  @JsonKey(ignore: true)
  _$ImportTokenEventDecimalChangedCopyWith<_ImportTokenEventDecimalChanged>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$ImportTokenStateTearOff {
  const _$ImportTokenStateTearOff();

  _ImportTokenState call(
      {required TextEditingController controllerSymbol,
      required TextEditingController controllerDecimal,
      String? tokenAddress,
      String? tokenSymbol,
      String? tokenDecimal,
      Status<dynamic> status = const Idle()}) {
    return _ImportTokenState(
      controllerSymbol: controllerSymbol,
      controllerDecimal: controllerDecimal,
      tokenAddress: tokenAddress,
      tokenSymbol: tokenSymbol,
      tokenDecimal: tokenDecimal,
      status: status,
    );
  }
}

/// @nodoc
const $ImportTokenState = _$ImportTokenStateTearOff();

/// @nodoc
mixin _$ImportTokenState {
  TextEditingController get controllerSymbol =>
      throw _privateConstructorUsedError;
  TextEditingController get controllerDecimal =>
      throw _privateConstructorUsedError;
  String? get tokenAddress => throw _privateConstructorUsedError;
  String? get tokenSymbol => throw _privateConstructorUsedError;
  String? get tokenDecimal => throw _privateConstructorUsedError;
  Status<dynamic> get status => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ImportTokenStateCopyWith<ImportTokenState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImportTokenStateCopyWith<$Res> {
  factory $ImportTokenStateCopyWith(
          ImportTokenState value, $Res Function(ImportTokenState) then) =
      _$ImportTokenStateCopyWithImpl<$Res>;
  $Res call(
      {TextEditingController controllerSymbol,
      TextEditingController controllerDecimal,
      String? tokenAddress,
      String? tokenSymbol,
      String? tokenDecimal,
      Status<dynamic> status});
}

/// @nodoc
class _$ImportTokenStateCopyWithImpl<$Res>
    implements $ImportTokenStateCopyWith<$Res> {
  _$ImportTokenStateCopyWithImpl(this._value, this._then);

  final ImportTokenState _value;
  // ignore: unused_field
  final $Res Function(ImportTokenState) _then;

  @override
  $Res call({
    Object? controllerSymbol = freezed,
    Object? controllerDecimal = freezed,
    Object? tokenAddress = freezed,
    Object? tokenSymbol = freezed,
    Object? tokenDecimal = freezed,
    Object? status = freezed,
  }) {
    return _then(_value.copyWith(
      controllerSymbol: controllerSymbol == freezed
          ? _value.controllerSymbol
          : controllerSymbol // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      controllerDecimal: controllerDecimal == freezed
          ? _value.controllerDecimal
          : controllerDecimal // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      tokenAddress: tokenAddress == freezed
          ? _value.tokenAddress
          : tokenAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenSymbol: tokenSymbol == freezed
          ? _value.tokenSymbol
          : tokenSymbol // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenDecimal: tokenDecimal == freezed
          ? _value.tokenDecimal
          : tokenDecimal // ignore: cast_nullable_to_non_nullable
              as String?,
      status: status == freezed
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Status<dynamic>,
    ));
  }
}

/// @nodoc
abstract class _$ImportTokenStateCopyWith<$Res>
    implements $ImportTokenStateCopyWith<$Res> {
  factory _$ImportTokenStateCopyWith(
          _ImportTokenState value, $Res Function(_ImportTokenState) then) =
      __$ImportTokenStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {TextEditingController controllerSymbol,
      TextEditingController controllerDecimal,
      String? tokenAddress,
      String? tokenSymbol,
      String? tokenDecimal,
      Status<dynamic> status});
}

/// @nodoc
class __$ImportTokenStateCopyWithImpl<$Res>
    extends _$ImportTokenStateCopyWithImpl<$Res>
    implements _$ImportTokenStateCopyWith<$Res> {
  __$ImportTokenStateCopyWithImpl(
      _ImportTokenState _value, $Res Function(_ImportTokenState) _then)
      : super(_value, (v) => _then(v as _ImportTokenState));

  @override
  _ImportTokenState get _value => super._value as _ImportTokenState;

  @override
  $Res call({
    Object? controllerSymbol = freezed,
    Object? controllerDecimal = freezed,
    Object? tokenAddress = freezed,
    Object? tokenSymbol = freezed,
    Object? tokenDecimal = freezed,
    Object? status = freezed,
  }) {
    return _then(_ImportTokenState(
      controllerSymbol: controllerSymbol == freezed
          ? _value.controllerSymbol
          : controllerSymbol // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      controllerDecimal: controllerDecimal == freezed
          ? _value.controllerDecimal
          : controllerDecimal // ignore: cast_nullable_to_non_nullable
              as TextEditingController,
      tokenAddress: tokenAddress == freezed
          ? _value.tokenAddress
          : tokenAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenSymbol: tokenSymbol == freezed
          ? _value.tokenSymbol
          : tokenSymbol // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenDecimal: tokenDecimal == freezed
          ? _value.tokenDecimal
          : tokenDecimal // ignore: cast_nullable_to_non_nullable
              as String?,
      status: status == freezed
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as Status<dynamic>,
    ));
  }
}

/// @nodoc

class _$_ImportTokenState implements _ImportTokenState {
  const _$_ImportTokenState(
      {required this.controllerSymbol,
      required this.controllerDecimal,
      this.tokenAddress,
      this.tokenSymbol,
      this.tokenDecimal,
      this.status = const Idle()});

  @override
  final TextEditingController controllerSymbol;
  @override
  final TextEditingController controllerDecimal;
  @override
  final String? tokenAddress;
  @override
  final String? tokenSymbol;
  @override
  final String? tokenDecimal;
  @JsonKey()
  @override
  final Status<dynamic> status;

  @override
  String toString() {
    return 'ImportTokenState(controllerSymbol: $controllerSymbol, controllerDecimal: $controllerDecimal, tokenAddress: $tokenAddress, tokenSymbol: $tokenSymbol, tokenDecimal: $tokenDecimal, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImportTokenState &&
            const DeepCollectionEquality()
                .equals(other.controllerSymbol, controllerSymbol) &&
            const DeepCollectionEquality()
                .equals(other.controllerDecimal, controllerDecimal) &&
            const DeepCollectionEquality()
                .equals(other.tokenAddress, tokenAddress) &&
            const DeepCollectionEquality()
                .equals(other.tokenSymbol, tokenSymbol) &&
            const DeepCollectionEquality()
                .equals(other.tokenDecimal, tokenDecimal) &&
            const DeepCollectionEquality().equals(other.status, status));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(controllerSymbol),
      const DeepCollectionEquality().hash(controllerDecimal),
      const DeepCollectionEquality().hash(tokenAddress),
      const DeepCollectionEquality().hash(tokenSymbol),
      const DeepCollectionEquality().hash(tokenDecimal),
      const DeepCollectionEquality().hash(status));

  @JsonKey(ignore: true)
  @override
  _$ImportTokenStateCopyWith<_ImportTokenState> get copyWith =>
      __$ImportTokenStateCopyWithImpl<_ImportTokenState>(this, _$identity);
}

abstract class _ImportTokenState implements ImportTokenState {
  const factory _ImportTokenState(
      {required TextEditingController controllerSymbol,
      required TextEditingController controllerDecimal,
      String? tokenAddress,
      String? tokenSymbol,
      String? tokenDecimal,
      Status<dynamic> status}) = _$_ImportTokenState;

  @override
  TextEditingController get controllerSymbol;
  @override
  TextEditingController get controllerDecimal;
  @override
  String? get tokenAddress;
  @override
  String? get tokenSymbol;
  @override
  String? get tokenDecimal;
  @override
  Status<dynamic> get status;
  @override
  @JsonKey(ignore: true)
  _$ImportTokenStateCopyWith<_ImportTokenState> get copyWith =>
      throw _privateConstructorUsedError;
}
